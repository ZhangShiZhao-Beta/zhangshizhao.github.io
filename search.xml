<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>What is OpenMp</title>
    <url>/2024/12/13/What-is-OpenMp/</url>
    <content><![CDATA[<h1 id="OpenMp定义"><a href="#OpenMp定义" class="headerlink" title="OpenMp定义"></a>OpenMp定义</h1><p>OpenMP 是一种用于<em><strong>共享内存</strong></em>和分布式共享内存多处理器的<em><strong>并行编程模型</strong></em>。<br>基于共享内存并行系统的跨平台多线程设计方案。</p>
<h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><ul>
<li>共享内存：OpenMp假定每一个线程都能访问到相同的内存。</li>
<li>并行编程模型：OpenMp是一个并行编程模型，类似于C++一样的规范，需要各个厂商自己实现。</li>
</ul>
<h1 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h1><p>对于分布式内存计算平台，如超算中心，OpenMp不适用在多个不共享的内存之间进行运行，一般是结合MPI(Message Passing Interface)，多核心之间使用MPI进行通信，单核心之间使用OpenMp进行计算。</p>
<h1 id="使用OpenMp的目的"><a href="#使用OpenMp的目的" class="headerlink" title="使用OpenMp的目的"></a>使用OpenMp的目的</h1><blockquote>
<p><strong>加速计算，不为了加速，无需用OpenMp</strong></p>
</blockquote>
<h1 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h1><p>减少并行计算开发的代价，提供简化方法，而无需关注的线程&#x2F;进程的管理和调用细节。</p>
<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>OPENMP使用指令（或称为编译指令、指示符）来指示编译器如何并行化程序中的部分代码。</p>
]]></content>
      <categories>
        <category>OpenMP</category>
      </categories>
  </entry>
  <entry>
    <title>OpenMp Simple Directives</title>
    <url>/2024/12/13/OpenMp-Simple-Directives/</url>
    <content><![CDATA[<h1 id="Normal-dircetives"><a href="#Normal-dircetives" class="headerlink" title="Normal dircetives"></a>Normal dircetives</h1><blockquote>
<p><strong>块并行指令</strong></p>
</blockquote>
<h2 id="1-pragma-omp-parallel"><a href="#1-pragma-omp-parallel" class="headerlink" title="1. #pragma omp parallel"></a>1. <code>#pragma omp parallel</code></h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Define a parallel region. 多个线程执行同一代码块</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">&#123;</span><br><span class="line">	xxxxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><blockquote>
<p><strong>创建多线程，执行同一代码块</strong><br>当程序遇到 <code>#pragma omp parallel</code> 时，OpenMP 会创建多个线程来执行该代码块，默认情况下每个线程将执行相同的代码。线程的数量可以通过设置环境变量或在指令中明确指定。</p>
</blockquote>
<h2 id="2-pragma-omp-parallel-sections-pragma-omp-section"><a href="#2-pragma-omp-parallel-sections-pragma-omp-section" class="headerlink" title="2. #pragma omp parallel sections &amp; #pragma omp section"></a>2. <code>#pragma omp parallel sections</code> &amp; <code>#pragma omp section</code></h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>分段协同工作结构（sections work-sharing construct），使用pragma omp section讲整个程序任务并行分割，openMp指定每个任务给不同的线程。</p>
<ul>
<li>问题：分割数量超过线程数怎么办？<ul>
<li>答：OpenMP 会通过<strong>动态分配线程</strong>的方式来处理这些 section</li>
</ul>
</li>
</ul>
<h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel sections</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">        &#123;</span><br><span class="line">            xxx</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">        &#123;</span><br><span class="line">            xxx</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">        &#123;</span><br><span class="line">            xxx</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">        &#123;</span><br><span class="line">            xxx</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><blockquote>
<p><strong>并行执行parallel sections中的section代码块，不在section块中的代码，不在本块内并行（除非被包含到更大的并行块中）。最好不要写在parallel sectionsd但不在section中的代码块，不同编译器实现不同</strong><br>创建线程池，分别执行程序员手动划分的代码块。程序会根据omp parallel sections中的section代码块进行分析，parallel section不是只允许有section代码块，omp会创建线程池去执行section块，只有用 <code>#pragma omp section</code> 标记的代码块才会被分配到不同的线程并行执行。不同的编译器实现有不同的表现，msvc不允许在section代码块后再添加非section代码块，gcc则可以。</p>
</blockquote>
<h2 id="3-pragma-omp-single"><a href="#3-pragma-omp-single" class="headerlink" title="3. #pragma omp single"></a>3. <code>#pragma omp single</code></h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p> 用于指定某段代码仅由一个线程执行，而其他线程会在这一点上等待，这里具有一个隐式屏障。<br> 如果不需要同步，可以用 <code>nowait</code> 修饰符移除隐式屏障。<br> <code>#pragma omp single nowait</code></p>
<blockquote>
<p>隐式屏障：等待点，所有线程执行完，再继续往后<br> OpenMP 中，当一个线程完成 <code>#pragma omp single</code> 代码块的执行后，所有线程会在这个代码块的末尾等待彼此，直到所有线程都到达这一点，然后再继续执行后续的代码。这种等待点被称为<strong>隐式屏障</strong>。</p>
</blockquote>
<h3 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h3><p>parallel中嵌套，用于线程间协调</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ompSingle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp single</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Section thread: &quot;</span> &lt;&lt; <span class="built_in">omp_get_thread_num</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Section thread: &quot;</span> &lt;&lt; <span class="built_in">omp_get_thread_num</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><blockquote>
<p><strong>线程选择、隐式屏障</strong><br>线程选择：择一线程执行。<br>隐式屏障：single代码块结束有一屏障机制，确保同步后再执行。</p>
</blockquote>
<h3 id="4-pragma-omp-parallel-for"><a href="#4-pragma-omp-parallel-for" class="headerlink" title="4.  #pragma omp parallel for"></a>4.  <code>#pragma omp parallel for</code></h3><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>创建一个并行区域，分配循环给区域内线程，每个线程执行一部分迭代。<br><del>&#x3D;{red}<em><strong>for必须是传统格式的for(initialization; condition; increment)</strong></em>&#x3D;</del><br><del>&#x3D;{red}只能是传统的计数器循环： 有符号的整形的递增&#x3D;</del></p>
<h3 id="用法-3"><a href="#用法-3" class="headerlink" title="用法"></a>用法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++) </span><br><span class="line">&#123; </span><br><span class="line">	vec[i] *= <span class="number">2</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><blockquote>
<p><strong>创建+分配+同步</strong><br><em><strong>创建线程、迭代范围分配、结尾隐式屏障用于同步</strong></em></p>
<ul>
<li><strong>创建线程团队</strong>：<code>parallel</code> 子句负责创建线程团队。</li>
<li><strong>迭代分配</strong>：循环的迭代范围被分配给各个线程，每个线程独立完成自己的部分。</li>
<li><strong>隐式屏障</strong>：循环结束时，所有线程在隐式屏障处同步，确保后续代码在所有线程完成任务后执行。</li>
</ul>
</blockquote>
<h2 id="Command-Rule"><a href="#Command-Rule" class="headerlink" title="Command Rule"></a>Command Rule</h2><h1 id="x-1-变量共享规则"><a href="#x-1-变量共享规则" class="headerlink" title="x.1 变量共享规则"></a>x.1 变量共享规则</h1><blockquote>
<p><strong>important</strong><br>关键在于哪些变量是共享的，哪些是线程私有的。</p>
</blockquote>
<h4 id="x-1-1-默认共享规则"><a href="#x-1-1-默认共享规则" class="headerlink" title="x.1.1 默认共享规则"></a>x.1.1 默认共享规则</h4><ul>
<li>在并行区域外定义变量默认为<del>&#x3D;{red}共享变量(shared)&#x3D;</del></li>
<li>在并行区域内部声明的局部变量，自动私有化<del>&#x3D;{red}私有变量(private)&#x3D;</del></li>
</ul>
<blockquote>
<p><strong>共享&#x2F;私有变量</strong><br>共享变量所有线程都可见，私有变量只有本线程可见。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OpenMpTest.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">	std::vector&lt;std::pair&lt;<span class="keyword">decltype</span>(&amp;x), <span class="keyword">decltype</span>(&amp;x)&gt;&gt; result;</span><br><span class="line">	<span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">	&#123;</span><br><span class="line">		x = <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line">		<span class="type">int</span> x_ = <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line">		<span class="comment">// 保证在同一时间内只有一个线程可以访问这段代码。</span></span><br><span class="line">		<span class="meta">#<span class="keyword">pragma</span> omp critical</span></span><br><span class="line">		&#123;</span><br><span class="line">			result.<span class="built_in">push_back</span>(&#123; &amp;x_, &amp;x &#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; p : result)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// x的地址在所有线程都一致，x_的地址都不一样。</span></span><br><span class="line">		std::cout &lt;&lt; p.first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.second &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="x-1-2-显式指定变量共享方式"><a href="#x-1-2-显式指定变量共享方式" class="headerlink" title="x.1.2 显式指定变量共享方式"></a>x.1.2 显式指定变量共享方式</h4><ul>
<li>default(xxx)：显式指定所有变量的共享方式。<ul>
<li>default(shared)：变量共享。默认方式(存疑)。</li>
<li>default(none)：不指定共享方式，并行区域内的使用了外部变量，需要明确指定。</li>
</ul>
</li>
<li><code>shared</code>: 明确指定一个或多个变量是共享的。<ul>
<li>一般用于于default(none)配合，用于明确指定变量共享方式<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">-100</span>;</span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="keyword">decltype</span>(&amp;x), <span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> printfVector = [](<span class="type">const</span> <span class="keyword">auto</span> array_)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;vector : &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; p : array_)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; p.first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.second &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">// 不指定共享方式，需要显式指定共享方式</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel default(none) shared(x, result)</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp critical</span></span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(&#123; &amp;x, x &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printfVector</span>(result);</span><br><span class="line">    std::cout &lt;&lt; &amp;x &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>private</code>: 明确指定一个或多个变量是私有的，每个线程拥有该变量的一个副本，原有变量的值不会被修改。<ul>
<li>注意此时值是没有被初始化的，相当于生成了一个未初始化的副本x。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">-100</span>;</span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="keyword">decltype</span>(&amp;x), <span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> printfVector = [](<span class="type">const</span> <span class="keyword">auto</span> array_)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;vector : &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; p : array_)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; p.first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.second &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel private(x)</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp critical</span></span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(&#123; &amp;x, x &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printfVector</span>(result);</span><br><span class="line">    std::cout &lt;&lt; &amp;x &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----- 输出</span><br><span class="line">vector :</span><br><span class="line"><span class="number">006</span>FF900, <span class="number">0</span></span><br><span class="line"><span class="number">007</span>FF960, <span class="number">1</span></span><br><span class="line"><span class="number">0336</span>FC68, <span class="number">13</span></span><br><span class="line"><span class="number">025</span>AFAA8, <span class="number">2</span></span><br><span class="line"><span class="number">02</span>82F900, <span class="number">4</span></span><br><span class="line"><span class="number">02</span>96F9C0, <span class="number">5</span></span><br><span class="line"><span class="number">02</span>AAFA20, <span class="number">6</span></span><br><span class="line"><span class="number">02</span>BEF860, <span class="number">7</span></span><br><span class="line"><span class="number">02</span>D2F818, <span class="number">8</span></span><br><span class="line"><span class="number">02E6F</span>E20, <span class="number">9</span></span><br><span class="line"><span class="number">02</span>FAF880, <span class="number">10</span></span><br><span class="line"><span class="number">030</span>EFAA8, <span class="number">11</span></span><br><span class="line"><span class="number">0322</span>F950, <span class="number">12</span></span><br><span class="line"><span class="number">034</span>AFBC0, <span class="number">14</span></span><br><span class="line"><span class="number">026</span>EFE48, <span class="number">3</span></span><br><span class="line"><span class="number">035</span>EFD20, <span class="number">15</span></span><br><span class="line">----------------------</span><br><span class="line"><span class="number">006</span>FFB40: <span class="number">-100</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>firstprivate</code>: 明确指定一个变量的私有副本，并且该副本的初值是变量在并行区域外的值。<ul>
<li>与private关键字的区别在于，有初始化，下边这段代码在vs2017会被警告变量未初始化。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">-100</span>;</span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; result;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel private(x)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> tempX = x;</span><br><span class="line">        x = <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp critical</span></span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(&#123; tempX, x &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
需要使用firstprivate关键字，用于初始化变量<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">-100</span>;</span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; result;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel firstprivate(x)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> tempX = x;</span><br><span class="line">        x = <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp critical</span></span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(&#123; tempX, x &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::for_each(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="keyword">auto</span>&amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; p.first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">----- 输出</span><br><span class="line"><span class="number">-100</span>, <span class="number">0</span></span><br><span class="line"><span class="number">-100</span>, <span class="number">10</span></span><br><span class="line"><span class="number">-100</span>, <span class="number">2</span></span><br><span class="line"><span class="number">-100</span>, <span class="number">1</span></span><br><span class="line"><span class="number">-100</span>, <span class="number">12</span></span><br><span class="line"><span class="number">-100</span>, <span class="number">4</span></span><br><span class="line"><span class="number">-100</span>, <span class="number">5</span></span><br><span class="line"><span class="number">-100</span>, <span class="number">6</span></span><br><span class="line"><span class="number">-100</span>, <span class="number">7</span></span><br><span class="line"><span class="number">-100</span>, <span class="number">8</span></span><br><span class="line"><span class="number">-100</span>, <span class="number">9</span></span><br><span class="line"><span class="number">-100</span>, <span class="number">11</span></span><br><span class="line"><span class="number">-100</span>, <span class="number">13</span></span><br><span class="line"><span class="number">-100</span>, <span class="number">14</span></span><br><span class="line"><span class="number">-100</span>, <span class="number">3</span></span><br><span class="line"><span class="number">-100</span>, <span class="number">15</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>lastprivate</code>: 用于某些变量的私有副本，在并行区域结束后，将最后一个线程的私有副本的值复制回原始变量。</li>
</ul>
<h4 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h4><p>标识的变量必须是已经声明了，shared(xxx)</p>
<h1 id="x-2-临界区-避免数据竞争"><a href="#x-2-临界区-避免数据竞争" class="headerlink" title="x.2 临界区-避免数据竞争"></a>x.2 临界区-避免数据竞争</h1><p><code>#pragma omp atomic</code> 和 <code>#pragma omp critical</code></p>
<h2 id="x-2-1-pragma-omp-critical"><a href="#x-2-1-pragma-omp-critical" class="headerlink" title="x.2.1 #pragma omp critical"></a>x.2.1 <code>#pragma omp critical</code></h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p><strong>定义临界区，在临界区内，某一时刻只允许一个线程执行代码</strong><br>用于定义一个<strong>临界区</strong>（critical section）。在这个区域内，某一时刻只允许一个线程执行代码，其它线程需要等待，直到当前线程退出临界区。</p>
</blockquote>
<h3 id="用法-4"><a href="#用法-4" class="headerlink" title="用法"></a>用法</h3><p>用于保护共享资源，提供同步机制，保证线程安全。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">-100</span>;</span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; result;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel firstprivate(x)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> tempX = x;</span><br><span class="line">        x = <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp critical</span></span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(&#123; tempX, x &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><p>通过加锁机制实现（如互斥锁），同一时间只能由一个线程访问该区域。<br>需要锁开销，对于简单做法，可以选择atomic</p>
<h2 id="x-2-2-pragma-omp-atomic"><a href="#x-2-2-pragma-omp-atomic" class="headerlink" title="x.2.2 #pragma omp atomic"></a>x.2.2 <code>#pragma omp atomic</code></h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p><strong>轻量级同步机制，用于对单个共享变量执行原子操作</strong></p>
</blockquote>
<ul>
<li>操作必须针对单个变量</li>
<li>只能保护单条语句</li>
</ul>
<h3 id="用法-5"><a href="#用法-5" class="headerlink" title="用法"></a>用法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> omp atomic</span></span><br><span class="line">        sum += i;  <span class="comment">// 原子加法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum = &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h3><p><code>#pragma omp atomic</code> 通常通过硬件支持的原子指令（如 CAS：Compare and Swap）或低层次锁来实现。相比于 <code>#pragma omp critical</code>，它的开销更低，因为只保护单个变量，不需要进入临界区管理多线程资源。</p>
<h1 id="x-3-归约操作"><a href="#x-3-归约操作" class="headerlink" title="x.3 归约操作"></a>x.3 归约操作</h1><h3 id="x-3-1-reduction关键字"><a href="#x-3-1-reduction关键字" class="headerlink" title="x.3.1 reduction关键字"></a>x.3.1 <code>reduction</code>关键字</h3><h2 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p><strong>归约操作</strong><br>将多个数据项（不同线程计算单元）合并成单一结果，即正确<em><strong>合并</strong></em>线程对共享变量的修改</p>
</blockquote>
<h2 id="用法-6"><a href="#用法-6" class="headerlink" title="用法"></a>用法</h2><p><code>#pragma omp parallel for reduction(operator: variable)</code><br>operator：用于归约的操作，用于归约的操作符，如 <code>+</code>、<code>*</code>、<code>&amp;</code> 等。<br>variable：需要进行归约的变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for reduction(+:sum)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        sum += arr[i];  <span class="comment">// 每个线程将自己计算的和存储到局部副本中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum = &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;  <span class="comment">// 输出最终的结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>支持的操作符</strong></p>
<ul>
<li><strong>加法</strong> (<code>+</code>)：将所有线程的局部结果进行加法运算。</li>
<li><strong>乘法</strong> (<code>*</code>)：将所有线程的局部结果进行乘法运算。</li>
<li><strong>按位与</strong> (<code>&amp;</code>)：对所有线程的局部结果进行按位与运算。</li>
<li><strong>按位或</strong> (<code>|</code>)：对所有线程的局部结果进行按位或运算。</li>
<li><strong>按位异或</strong> (<code>^</code>)：对所有线程的局部结果进行按位异或运算。</li>
<li><strong>逻辑与</strong> (<code>&amp;&amp;</code>)：对所有线程的局部结果进行逻辑与运算。</li>
<li><strong>逻辑或</strong> (<code>||</code>)：对所有线程的局部结果进行逻辑或运算。</li>
<li><strong>最小值</strong> (<code>min</code>)：返回多个线程局部值中的最小值。</li>
<li><strong>最大值</strong> (<code>max</code>)：返回多个线程局部值中的最大值。</li>
</ul>
</blockquote>
<h2 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h2><blockquote>
<p><strong>局部副本：OpenMP 会为每个线程创建一个局部副本，线程在并行区域内对这个副本进行操作。</strong></p>
</blockquote>
<ul>
<li>omp只会对reduction声明的变量创建局部副本。</li>
<li>根据规则会初始化每一个副本的初始值：<ul>
<li>加法：副本初始值为0</li>
<li>乘法：副本初始值为1</li>
<li>逻辑运算&amp;&amp;：初始值为true</li>
<li>逻辑运算||：初始值为false</li>
<li>位操作&amp;：初始值位~0（即全1）</li>
<li>位操作|，位操作^：初始值0<br> <em><strong>原则：初始值不影响归约结果</strong></em></li>
</ul>
</li>
<li>如果变量已经有了一个初始值，则会将该初始值，参与到最后的归约操作中。如加法归约：initializer + sum_0 + sum_1 + …</li>
</ul>
<blockquote>
<p><strong>合并操作</strong><br>并行区域结束后，OpenMP 会自动将各线程的局部结果合并，得到全局结果。</p>
</blockquote>
<h2 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h2><blockquote>
<p><strong>important</strong><br><em><strong>流程</strong></em>：<br>创建局部副本-&gt;副本初始化-&gt;副本参与计算（因为是副本，所以没有竞争风险）-&gt;根据归约操作副本结果</p>
</blockquote>
<ul>
<li>归约操作只对声明变量负责，允许多个归约</li>
</ul>
<h2 id="自定义归约操作-declare-reduction（MSVC不支持）"><a href="#自定义归约操作-declare-reduction（MSVC不支持）" class="headerlink" title="自定义归约操作 declare reduction（MSVC不支持）"></a>自定义归约操作 declare reduction（MSVC不支持）</h2><h2 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h2><p>指令</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp declare reduction(identifier : type : combiner) \</span></span><br><span class="line"><span class="meta">    initializer(initializer_expression)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>**<code>identifier</code>**：归约操作符的名称。</li>
<li>**<code>type</code>**：应用于归约变量的类型。</li>
<li>**<code>combiner</code>**：定义如何将不同线程的私有副本合并到一起。<ul>
<li>需要是表达式</li>
<li><code>omp_out</code>: 归约变量，即最终结果变量</li>
<li><code>omp_in</code>：当前线程归约变量，即操作变量</li>
</ul>
</li>
<li>**<code>initializer</code>**：定义每个线程中归约变量的初始值。<ul>
<li>表达式</li>
<li>omp_priv：表示线程私有归约变量</li>
<li>omp_orig：线程共享全局归约变量</li>
</ul>
</li>
</ul>
<h2 id="用法-7"><a href="#用法-7" class="headerlink" title="用法"></a>用法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i) : <span class="built_in">a</span>(i)&#123;&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getA</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setA</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        a = i;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">combine</span><span class="params">(A&amp; out, <span class="type">const</span> A&amp; in)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        out.<span class="built_in">setA</span>(out.<span class="built_in">getA</span>() + in.<span class="built_in">getA</span>());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp declare reduction(APluse : A : A::combine(omp_out, omp_in))\</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line">    <span class="built_in">initializer</span>(omp_priv = <span class="built_in">A</span>(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ompDecRefuction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for reduction(APluse : a)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">omp_get_num_threads</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        a.<span class="built_in">setA</span>(i + a.<span class="built_in">getA</span>());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; a.<span class="built_in">getA</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="手动自定义归约操作"><a href="#手动自定义归约操作" class="headerlink" title="手动自定义归约操作"></a>手动自定义归约操作</h2><p>不支持自定义归约操作的编译器，可以考虑手动创建临界区进行归约操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">manualReduction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> global_sum = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">    &#123; <span class="type">int</span> local_sum = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        local_sum += i;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp critical</span></span><br><span class="line">    &#123;</span><br><span class="line">        global_sum += local_sum;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; global_sum &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="X-4-其他线程操作-后缀"><a href="#X-4-其他线程操作-后缀" class="headerlink" title="X.4 其他线程操作-后缀"></a>X.4 其他线程操作-后缀</h1><h2 id="x-4-1-nowait-跳过内存屏障"><a href="#x-4-1-nowait-跳过内存屏障" class="headerlink" title="x.4.1 nowait 跳过内存屏障"></a>x.4.1 <code>nowait</code> 跳过内存屏障</h2><ul>
<li>跳过<code>parallel for</code>，<code>parallel sections</code>默认的内存屏障。</li>
<li>不能用于<code>omp parallel</code></li>
<li>主线程继续往下走，不等所有线程执行结束再往下执行<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for reduction(+:sum) nowait</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        sum += arr[i];  <span class="comment">// 每个线程将自己计算的和存储到局部副本中</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="x-4-2-num-threads-n-设置线程数量为n"><a href="#x-4-2-num-threads-n-设置线程数量为n" class="headerlink" title="x.4.2 num_threads(n)设置线程数量为n"></a>x.4.2 <code>num_threads(n)</code>设置线程数量为n</h2><ul>
<li>线程的最大数量通常受硬件资源限制（如 CPU 核心数和内存大小）。</li>
</ul>
<ul>
<li>如果指定的线程数大于硬件核心数，线程调度开销可能会降低性能。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel num_threads(4) <span class="comment">// 局部设置线程数为 4 </span></span></span><br><span class="line">&#123; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Local: Thread %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="X-5-其他线程操作-函数调用"><a href="#X-5-其他线程操作-函数调用" class="headerlink" title="X.5 其他线程操作-函数调用"></a>X.5 其他线程操作-函数调用</h1><h2 id="x-5-1-omp-get-thread-num-获取当前线程ID"><a href="#x-5-1-omp-get-thread-num-获取当前线程ID" class="headerlink" title="x.5.1 omp_get_thread_num()  获取当前线程ID"></a>x.5.1 <code>omp_get_thread_num()</code>  获取当前线程ID</h2><h2 id="x-5-2-omp-get-num-threads-获取当前并行区域的总线程数"><a href="#x-5-2-omp-get-num-threads-获取当前并行区域的总线程数" class="headerlink" title="x.5.2 omp_get_num_threads() 获取当前并行区域的总线程数"></a>x.5.2 <code>omp_get_num_threads()</code> 获取当前并行区域的总线程数</h2><h1 id="X-6-omp-parallel和omp-for结合"><a href="#X-6-omp-parallel和omp-for结合" class="headerlink" title="X.6 omp parallel和omp for结合"></a>X.6 omp parallel和omp for结合</h1><h2 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h2><p>当 <code>#pragma omp parallel</code> 和 <code>#pragma omp for</code> 嵌套使用时，<code>for</code> 循环的行为是 <strong>拆分任务，而不是重复调用</strong>。<br>OpenMP 的工作原理是通过线程池并行执行代码，其中 <code>#pragma omp parallel</code> 创建线程组，而 <code>#pragma omp for</code> 则将循环迭代分配给这些线程。<br>因此</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">------等同于</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OpenMP</category>
      </categories>
  </entry>
</search>
